diff -Nuar a/examples/qml/doc/src/qml-extending.qdoc b/examples/qml/doc/src/qml-extending.qdoc
--- a/examples/qml/doc/src/qml-extending.qdoc	2020-10-27 11:02:12.000000000 +0300
+++ b/examples/qml/doc/src/qml-extending.qdoc	2021-11-16 15:55:38.968626527 +0300
@@ -79,6 +79,10 @@
 
 \snippet referenceexamples/extended/lineedit.h 0
 
+Note the usage of \l QML_NAMED_ELEMENT() instead of \l QML_ELEMENT.
+QML_ELEMENT uses the name of the containing type by default, "LineEditExtension" in this case.
+As the class being an extension class is an implementation detail, we choose the more natural name "LineEdit" instead
+
 The QML engine then instantiates a \l QLineEdit:
 
 \snippet referenceexamples/extended/main.cpp 1
diff -Nuar a/src/3rdparty/masm/assembler/AssemblerBuffer.h b/src/3rdparty/masm/assembler/AssemblerBuffer.h
--- a/src/3rdparty/masm/assembler/AssemblerBuffer.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/3rdparty/masm/assembler/AssemblerBuffer.h	2021-11-16 15:55:38.968626527 +0300
@@ -140,9 +140,9 @@
             if (!result)
                 return 0;
 
-            ExecutableAllocator::makeWritable(result->start(), result->sizeInBytes());
+            ExecutableAllocator::makeWritable(result->memoryStart(), result->memorySize());
 
-            memcpy(result->start(), m_buffer, m_index);
+            memcpy(result->codeStart(), m_buffer, m_index);
             
             return result.release();
         }
diff -Nuar a/src/3rdparty/masm/assembler/LinkBuffer.h b/src/3rdparty/masm/assembler/LinkBuffer.h
--- a/src/3rdparty/masm/assembler/LinkBuffer.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/3rdparty/masm/assembler/LinkBuffer.h	2021-11-16 15:55:38.969626527 +0300
@@ -333,7 +333,7 @@
     m_executableMemory = m_assembler->m_assembler.executableCopy(*m_globalData, ownerUID, effort);
     if (!m_executableMemory)
         return;
-    m_code = m_executableMemory->start();
+    m_code = m_executableMemory->codeStart();
     m_size = m_assembler->m_assembler.codeSize();
     ASSERT(m_code);
 }
@@ -355,7 +355,8 @@
 template <typename MacroAssembler, template <typename T> class ExecutableOffsetCalculator>
 inline void LinkBufferBase<MacroAssembler, ExecutableOffsetCalculator>::makeExecutable()
 {
-    ExecutableAllocator::makeExecutable(code(), static_cast<int>(m_size));
+    ExecutableAllocator::makeExecutable(m_executableMemory->memoryStart(),
+                                        m_executableMemory->memorySize());
 }
 
 template <typename MacroAssembler>
@@ -442,9 +443,9 @@
     m_executableMemory = m_globalData->executableAllocator.allocate(*m_globalData, m_initialSize, ownerUID, effort);
     if (!m_executableMemory)
         return;
-    m_code = (uint8_t*)m_executableMemory->start();
+    m_code = (uint8_t*)m_executableMemory->codeStart();
     ASSERT(m_code);
-    ExecutableAllocator::makeWritable(m_code, m_initialSize);
+    ExecutableAllocator::makeWritable(m_executableMemory->memoryStart(), m_executableMemory->memorySize());
     uint8_t* inData = (uint8_t*)m_assembler->unlinkedCode();
     uint8_t* outData = reinterpret_cast<uint8_t*>(m_code);
     int readPtr = 0;
diff -Nuar a/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h b/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h
--- a/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h	2021-11-16 15:55:38.969626527 +0300
@@ -357,11 +357,11 @@
     }
 
     MacroAssemblerCodeRef(PassRefPtr<ExecutableMemoryHandle> executableMemory)
-        : m_codePtr(executableMemory->start())
+        : m_codePtr(executableMemory->codeStart())
         , m_executableMemory(executableMemory)
     {
         ASSERT(m_executableMemory->isManaged());
-        ASSERT(m_executableMemory->start());
+        ASSERT(m_executableMemory->codeStart());
         ASSERT(m_codePtr);
     }
     
@@ -395,7 +395,7 @@
     {
         if (!m_executableMemory)
             return 0;
-        return m_executableMemory->sizeInBytes();
+        return m_executableMemory->codeSize();
     }
     
     bool tryToDisassemble(const char* prefix) const
diff -Nuar a/src/3rdparty/masm/stubs/ExecutableAllocator.h b/src/3rdparty/masm/stubs/ExecutableAllocator.h
--- a/src/3rdparty/masm/stubs/ExecutableAllocator.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/3rdparty/masm/stubs/ExecutableAllocator.h	2021-11-16 15:55:38.969626527 +0300
@@ -82,9 +82,14 @@
 
     inline bool isManaged() const { return true; }
 
-    void *exceptionHandler() { return m_allocation->exceptionHandler(); }
-    void *start() { return m_allocation->start(); }
-    size_t sizeInBytes() { return m_size; }
+    void *memoryStart() { return m_allocation->memoryStart(); }
+    size_t memorySize() { return m_allocation->memorySize(); }
+
+    void *exceptionHandlerStart() { return m_allocation->exceptionHandlerStart(); }
+    size_t exceptionHandlerSize() { return m_allocation->exceptionHandlerSize(); }
+
+    void *codeStart() { return m_allocation->codeStart(); }
+    size_t codeSize() { return m_size; }
 
     QV4::ExecutableAllocator::ChunkOfPages *chunk() const
     { return m_allocator->chunkForAllocation(m_allocation); }
diff -Nuar a/src/3rdparty/masm/yarr/Yarr.h b/src/3rdparty/masm/yarr/Yarr.h
--- a/src/3rdparty/masm/yarr/Yarr.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/3rdparty/masm/yarr/Yarr.h	2021-11-16 15:55:38.969626527 +0300
@@ -28,6 +28,7 @@
 #pragma once
 
 #include <limits.h>
+#include <limits>
 #include "YarrErrorCode.h"
 
 namespace JSC { namespace Yarr {
diff -Nuar a/src/imports/folderlistmodel/plugin.cpp b/src/imports/folderlistmodel/plugin.cpp
--- a/src/imports/folderlistmodel/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/folderlistmodel/plugin.cpp	2021-11-16 15:55:38.969626527 +0300
@@ -43,6 +43,7 @@
 #include "qquickfolderlistmodel.h"
 
 extern void qml_register_types_Qt_labs_folderlistmodel();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_folderlistmodel);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/labsanimation/plugin.cpp b/src/imports/labsanimation/plugin.cpp
--- a/src/imports/labsanimation/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/labsanimation/plugin.cpp	2021-11-16 15:55:38.969626527 +0300
@@ -43,6 +43,7 @@
 #include "qquickboundaryrule_p.h"
 
 extern void qml_register_types_Qt_labs_animation();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_animation);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/labsmodels/plugin.cpp b/src/imports/labsmodels/plugin.cpp
--- a/src/imports/labsmodels/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/labsmodels/plugin.cpp	2021-11-16 15:55:38.969626527 +0300
@@ -51,6 +51,7 @@
 #endif
 
 extern void qml_register_types_Qt_labs_qmlmodels();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_qmlmodels);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/layouts/plugin.cpp b/src/imports/layouts/plugin.cpp
--- a/src/imports/layouts/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/layouts/plugin.cpp	2021-11-16 15:55:38.970626527 +0300
@@ -43,6 +43,7 @@
 #include "qquickstacklayout_p.h"
 
 extern void qml_register_types_QtQuick_Layouts();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Layouts);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/localstorage/plugin.cpp b/src/imports/localstorage/plugin.cpp
--- a/src/imports/localstorage/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/localstorage/plugin.cpp	2021-11-16 15:55:38.970626527 +0300
@@ -43,6 +43,7 @@
 #include <QtQml/qqml.h>
 
 extern void qml_register_types_QtQuick_LocalStorage();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_LocalStorage);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/settings/plugin.cpp b/src/imports/settings/plugin.cpp
--- a/src/imports/settings/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/settings/plugin.cpp	2021-11-16 15:55:38.970626527 +0300
@@ -43,6 +43,7 @@
 #include "qqmlsettings_p.h"
 
 extern void qml_register_types_Qt_labs_settings();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_settings);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/sharedimage/plugin.cpp b/src/imports/sharedimage/plugin.cpp
--- a/src/imports/sharedimage/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/sharedimage/plugin.cpp	2021-11-16 15:55:38.970626527 +0300
@@ -100,6 +100,7 @@
 */
 
 extern void qml_register_types_Qt_labs_sharedimage();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_sharedimage);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/statemachine/plugin.cpp b/src/imports/statemachine/plugin.cpp
--- a/src/imports/statemachine/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/statemachine/plugin.cpp	2021-11-16 15:55:38.970626527 +0300
@@ -49,6 +49,7 @@
 #include <qqml.h>
 
 extern void qml_register_types_QtQml_StateMachine();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_StateMachine);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/testlib/main.cpp b/src/imports/testlib/main.cpp
--- a/src/imports/testlib/main.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/testlib/main.cpp	2021-11-16 15:55:38.970626527 +0300
@@ -51,6 +51,7 @@
 QML_DECLARE_TYPE(QuickTestUtil)
 
 extern void qml_register_types_QtTest();
+GHS_KEEP_REFERENCE(qml_register_types_QtTest);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/wavefrontmesh/plugin.cpp b/src/imports/wavefrontmesh/plugin.cpp
--- a/src/imports/wavefrontmesh/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/wavefrontmesh/plugin.cpp	2021-11-16 15:55:38.970626527 +0300
@@ -43,6 +43,7 @@
 #include "qwavefrontmesh.h"
 
 extern void qml_register_types_Qt_labs_wavefrontmesh();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_wavefrontmesh);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/imports/window/plugin.cpp b/src/imports/window/plugin.cpp
--- a/src/imports/window/plugin.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/imports/window/plugin.cpp	2021-11-16 15:55:38.971626527 +0300
@@ -42,6 +42,7 @@
 #include "plugin.h"
 
 extern void qml_register_types_QtQuick_Window();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Window);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/particles/qtquickparticlesglobal_p.h b/src/particles/qtquickparticlesglobal_p.h
--- a/src/particles/qtquickparticlesglobal_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/particles/qtquickparticlesglobal_p.h	2021-11-16 15:55:38.971626527 +0300
@@ -66,5 +66,6 @@
 #endif
 
 void Q_QUICKPARTICLES_PRIVATE_EXPORT qml_register_types_QtQuick_Particles();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Particles);
 
 #endif // QTQUICKPARTICLESGLOBAL_P_H
diff -Nuar a/src/qml/doc/src/cppintegration/definetypes.qdoc b/src/qml/doc/src/cppintegration/definetypes.qdoc
--- a/src/qml/doc/src/cppintegration/definetypes.qdoc	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/doc/src/cppintegration/definetypes.qdoc	2021-11-16 15:55:38.971626527 +0300
@@ -117,6 +117,14 @@
 QML_IMPORT_MAJOR_VERSION = 1
 \endcode
 
+If the header the class is declared in is not accessible from your project's
+include path, you may have to amend the include path so that the generated
+registration code can be compiled:
+
+\code
+INCLUDEPATH += com/mycompany/messaging
+\endcode
+
 The type can be used in an \l{qtqml-syntax-basics.html#object-declarations}
 {object declaration} from QML, and its properties can be read and written to,
 as per the example below:
diff -Nuar a/src/qml/doc/src/qmlfunctions.qdoc b/src/qml/doc/src/qmlfunctions.qdoc
--- a/src/qml/doc/src/qmlfunctions.qdoc	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/doc/src/qmlfunctions.qdoc	2021-11-16 15:55:38.971626527 +0300
@@ -250,6 +250,10 @@
   This is useful for registering types that cannot be amended to add the macros,
   for example because they belong to 3rdparty libraries.
 
+  \b{NOTE:} You may want to use \l QML_NAMED_ELEMENT() instead of \l QML_ELEMENT due to the fact that
+  the element will be named like the struct it is contained in, not the foreign type.
+  See \l {Extending QML - Extension Objects Example} for an example.
+
   \sa QML_ELEMENT, QML_NAMED_ELEMENT()
 */
 
diff -Nuar a/src/qml/jsruntime/qv4executableallocator.cpp b/src/qml/jsruntime/qv4executableallocator.cpp
--- a/src/qml/jsruntime/qv4executableallocator.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/jsruntime/qv4executableallocator.cpp	2021-11-16 15:55:38.972626527 +0300
@@ -45,12 +45,22 @@
 
 using namespace QV4;
 
-void *ExecutableAllocator::Allocation::exceptionHandler() const
+void *ExecutableAllocator::Allocation::exceptionHandlerStart() const
 {
     return reinterpret_cast<void*>(addr);
 }
 
-void *ExecutableAllocator::Allocation::start() const
+size_t ExecutableAllocator::Allocation::exceptionHandlerSize() const
+{
+    return QV4::exceptionHandlerSize();
+}
+
+void *ExecutableAllocator::Allocation::memoryStart() const
+{
+    return reinterpret_cast<void*>(addr);
+}
+
+void *ExecutableAllocator::Allocation::codeStart() const
 {
     return reinterpret_cast<void*>(addr + exceptionHandlerSize());
 }
diff -Nuar a/src/qml/jsruntime/qv4executableallocator_p.h b/src/qml/jsruntime/qv4executableallocator_p.h
--- a/src/qml/jsruntime/qv4executableallocator_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/jsruntime/qv4executableallocator_p.h	2021-11-16 15:55:38.972626527 +0300
@@ -86,8 +86,14 @@
             , free(true)
         {}
 
-        void *exceptionHandler() const;
-        void *start() const;
+        void *memoryStart() const;
+        size_t memorySize() const { return size; }
+
+        void *exceptionHandlerStart() const;
+        size_t exceptionHandlerSize() const;
+
+        void *codeStart() const;
+
         void invalidate() { addr = 0; }
         bool isValid() const { return addr != 0; }
         void deallocate(ExecutableAllocator *allocator);
diff -Nuar a/src/qml/jsruntime/qv4functiontable_win64.cpp b/src/qml/jsruntime/qv4functiontable_win64.cpp
--- a/src/qml/jsruntime/qv4functiontable_win64.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/jsruntime/qv4functiontable_win64.cpp	2021-11-16 15:55:38.972626527 +0300
@@ -106,7 +106,7 @@
 void generateFunctionTable(Function *, JSC::MacroAssemblerCodeRef *codeRef)
 {
     ExceptionHandlerRecord *record = reinterpret_cast<ExceptionHandlerRecord *>(
-                codeRef->executableMemory()->exceptionHandler());
+                codeRef->executableMemory()->exceptionHandlerStart());
 
     record->info.Version             = 1;
     record->info.Flags               = 0;
@@ -136,7 +136,7 @@
 void destroyFunctionTable(Function *, JSC::MacroAssemblerCodeRef *codeRef)
 {
     ExceptionHandlerRecord *record = reinterpret_cast<ExceptionHandlerRecord *>(
-                codeRef->executableMemory()->exceptionHandler());
+                codeRef->executableMemory()->exceptionHandlerStart());
     if (!RtlDeleteFunctionTable(&record->handler)) {
         const unsigned int errorCode = GetLastError();
         qWarning() << "Failed to remove win64 unwind hook. Error code:" << errorCode;
diff -Nuar a/src/qml/jsruntime/qv4proxy.cpp b/src/qml/jsruntime/qv4proxy.cpp
--- a/src/qml/jsruntime/qv4proxy.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/jsruntime/qv4proxy.cpp	2021-11-16 15:55:38.972626527 +0300
@@ -265,9 +265,9 @@
     ScopedProperty targetDesc(scope);
     PropertyAttributes targetAttributes = target->getOwnProperty(id, targetDesc);
     if (trapResult->isUndefined()) {
-        p->value = Encode::undefined();
-        if (targetAttributes == Attr_Invalid) {
+        if (p)
             p->value = Encode::undefined();
+        if (targetAttributes == Attr_Invalid) {
             return Attr_Invalid;
         }
         if (!targetAttributes.isConfigurable() || !target->isExtensible()) {
@@ -295,8 +295,10 @@
         }
     }
 
-    p->value = resultDesc->value;
-    p->set = resultDesc->set;
+    if (p) {
+        p->value = resultDesc->value;
+        p->set = resultDesc->set;
+    }
     return resultAttributes;
 }
 
@@ -622,8 +624,10 @@
         else
             targetNonConfigurableKeys->push_back(keyAsValue);
     }
-    if (target->isExtensible() && targetNonConfigurableKeys->getLength() == 0)
+    if (target->isExtensible() && targetNonConfigurableKeys->getLength() == 0) {
+        *iteratorTarget = *m;
         return new ProxyObjectOwnPropertyKeyIterator(trapKeys);
+    }
 
     ScopedArrayObject uncheckedResultKeys(scope, scope.engine->newArrayObject());
     uncheckedResultKeys->copyArrayData(trapKeys);
@@ -637,8 +641,10 @@
         }
     }
 
-    if (target->isExtensible())
+    if (target->isExtensible()) {
+        *iteratorTarget = *m;
         return new ProxyObjectOwnPropertyKeyIterator(trapKeys);
+    }
 
     len = targetConfigurableKeys->getLength();
     for (uint i = 0; i < len; ++i) {
diff -Nuar a/src/qml/jsruntime/qv4qmlcontext.cpp b/src/qml/jsruntime/qv4qmlcontext.cpp
--- a/src/qml/jsruntime/qv4qmlcontext.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/jsruntime/qv4qmlcontext.cpp	2021-11-16 15:55:38.973626527 +0300
@@ -466,9 +466,9 @@
                 return static_cast<Heap::CallContext *>(ctx)->locals[index].asReturnedValue();
         }
 
-        // Skip only block contexts within the current call context.
+        // Skip only block and call contexts.
         // Other contexts need a regular QML property lookup. See below.
-        if (ctx->type != Heap::ExecutionContext::Type_BlockContext)
+        if (ctx->type != Heap::ExecutionContext::Type_BlockContext && ctx->type != Heap::ExecutionContext::Type_CallContext)
             break;
     }
 
diff -Nuar a/src/qml/memory/qv4mm.cpp b/src/qml/memory/qv4mm.cpp
--- a/src/qml/memory/qv4mm.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/memory/qv4mm.cpp	2021-11-16 15:55:38.973626527 +0300
@@ -981,7 +981,7 @@
 
     if (MultiplyWrappedQObjectMap *multiplyWrappedQObjects = engine->m_multiplyWrappedQObjects) {
         for (MultiplyWrappedQObjectMap::Iterator it = multiplyWrappedQObjects->begin(); it != multiplyWrappedQObjects->end();) {
-            if (!it.value().isNullOrUndefined())
+            if (it.value().isNullOrUndefined())
                 it = multiplyWrappedQObjects->erase(it);
             else
                 ++it;
diff -Nuar a/src/qml/qml/qqmlextensionplugin.h b/src/qml/qml/qqmlextensionplugin.h
--- a/src/qml/qml/qqmlextensionplugin.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/qml/qqmlextensionplugin.h	2021-11-16 15:55:38.973626527 +0300
@@ -44,6 +44,13 @@
 #include <QtCore/QUrl>
 #include <QtQml/qqmlextensioninterface.h>
 
+#if defined(Q_CC_GHS)
+#  define GHS_PRAGMA(S) _Pragma(#S)
+#  define GHS_KEEP_REFERENCE(S) GHS_PRAGMA(ghs reference S ##__Fv)
+#else
+#  define GHS_KEEP_REFERENCE(S)
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QQmlEngine;
diff -Nuar a/src/qml/qml/qqmlpropertycachecreator.cpp b/src/qml/qml/qqmlpropertycachecreator.cpp
--- a/src/qml/qml/qqmlpropertycachecreator.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/qml/qqmlpropertycachecreator.cpp	2021-11-16 15:55:38.973626527 +0300
@@ -90,6 +90,15 @@
             QByteArray::number(classIndexCounter.fetchAndAddRelaxed(1));
 }
 
+QByteArray QQmlPropertyCacheCreatorBase::createClassNameForInlineComponent(const QUrl &baseUrl, int icId)
+{
+    QByteArray baseName = createClassNameTypeByUrl(baseUrl);
+    if (baseName.isEmpty())
+        baseName = QByteArray("ANON_QML_IC_") + QByteArray::number(classIndexCounter.fetchAndAddRelaxed(1));
+    baseName += "_" + QByteArray::number(icId);
+    return baseName;
+}
+
 QQmlBindingInstantiationContext::QQmlBindingInstantiationContext(int referencingObjectIndex, const QV4::CompiledData::Binding *instantiatingBinding,
                                                                  const QString &instantiatingPropertyName, QQmlPropertyCache *referencingObjectPropertyCache)
     : referencingObjectIndex(referencingObjectIndex)
diff -Nuar a/src/qml/qml/qqmlpropertycachecreator_p.h b/src/qml/qml/qqmlpropertycachecreator_p.h
--- a/src/qml/qml/qqmlpropertycachecreator_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/qml/qqmlpropertycachecreator_p.h	2021-11-16 15:55:38.974626527 +0300
@@ -104,6 +104,8 @@
     static int metaTypeForPropertyType(QV4::CompiledData::BuiltinType type);
 
     static QByteArray createClassNameTypeByUrl(const QUrl &url);
+
+    static QByteArray createClassNameForInlineComponent(const QUrl &baseUrl, int icId);
 };
 
 template <typename ObjectContainer>
diff -Nuar a/src/qml/qml/qqmlpropertyvalidator.cpp b/src/qml/qml/qqmlpropertyvalidator.cpp
--- a/src/qml/qml/qqmlpropertyvalidator.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/qml/qqmlpropertyvalidator.cpp	2021-11-16 15:55:38.974626527 +0300
@@ -651,6 +651,19 @@
 {
     QQmlPropertyCache *toMo = enginePrivate->rawPropertyCacheForType(to);
 
+    if (toMo == nullptr) {
+        // if we have an inline component from the current file,
+        // it is not properly registered at this point, as registration
+        // only occurs after the whole file has been validated
+        // Therefore we need to check the ICs here
+        for (const auto& icDatum : compilationUnit->inlineComponentData) {
+            if (icDatum.typeIds.id == to) {
+                toMo = compilationUnit->propertyCaches.at(icDatum.objectIndex);
+                break;
+            }
+        }
+    }
+
     while (fromMo) {
         if (fromMo == toMo)
             return true;
@@ -746,6 +759,18 @@
         // effect the properties on the type, but don't effect assignability
         // Using -1 for the minor version ensures that we get the raw metaObject.
         QQmlPropertyCache *propertyMetaObject = enginePrivate->rawPropertyCacheForType(propType, -1);
+        if (!propertyMetaObject) {
+            // if we have an inline component from the current file,
+            // it is not properly registered at this point, as registration
+            // only occurs after the whole file has been validated
+            // Therefore we need to check the ICs here
+            for (const auto& icDatum: compilationUnit->inlineComponentData) {
+                if (icDatum.typeIds.id == property->propType()) {
+                    propertyMetaObject = compilationUnit->propertyCaches.at(icDatum.objectIndex);
+                    break;
+                }
+            }
+        }
 
         if (propertyMetaObject) {
             // Will be true if the assigned type inherits propertyMetaObject
diff -Nuar a/src/qml/qml/qqmltypedata.cpp b/src/qml/qml/qqmltypedata.cpp
--- a/src/qml/qml/qqmltypedata.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/qml/qqmltypedata.cpp	2021-11-16 15:55:38.974626527 +0300
@@ -283,9 +283,7 @@
     for (int i = 0; i != container->objectCount(); ++i) {
         auto root = container->objectAt(i);
         for (auto it = root->inlineComponentsBegin(); it != root->inlineComponentsEnd(); ++it) {
-            auto url = finalUrl;
-            url.setFragment(QString::number(it->objectIndex));
-            const QByteArray &className = QQmlPropertyCacheCreatorBase::createClassNameTypeByUrl(url);
+            const QByteArray &className = QQmlPropertyCacheCreatorBase::createClassNameForInlineComponent(finalUrl, it->objectIndex);
             InlineComponentData icDatum(QQmlMetaType::registerInternalCompositeType(className), int(it->objectIndex), int(it->nameIndex), 0, 0, 0);
             icData->insert(it->objectIndex, icDatum);
         }
diff -Nuar a/src/qml/qtqmlglobal_p.h b/src/qml/qtqmlglobal_p.h
--- a/src/qml/qtqmlglobal_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qml/qtqmlglobal_p.h	2021-11-16 15:55:38.975626527 +0300
@@ -53,6 +53,7 @@
 
 #include <QtCore/private/qglobal_p.h>
 #include <QtQml/qtqmlglobal.h>
+#include <QtQml/qqmlextensionplugin.h>
 #ifndef QT_QML_BOOTSTRAPPED
 #  include <QtQml/private/qtqml-config_p.h>
 #endif
@@ -61,6 +62,7 @@
 #define Q_QML_PRIVATE_EXPORT Q_QML_EXPORT
 
 void Q_QML_PRIVATE_EXPORT qml_register_types_QtQml();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml);
 
 #if !defined(QT_QMLDEVTOOLS_LIB) && !defined(QT_BUILD_QMLDEVTOOLS_LIB)
 #  define Q_QML_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
diff -Nuar a/src/qmldebug/qqmlprofilerevent_p.h b/src/qmldebug/qqmlprofilerevent_p.h
--- a/src/qmldebug/qqmlprofilerevent_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qmldebug/qqmlprofilerevent_p.h	2021-11-16 15:55:38.975626527 +0300
@@ -48,6 +48,7 @@
 #include <QtCore/qmetatype.h>
 
 #include <initializer_list>
+#include <limits>
 #include <type_traits>
 
 //
diff -Nuar a/src/qmlmodels/qqmldelegatemodel.cpp b/src/qmlmodels/qqmldelegatemodel.cpp
--- a/src/qmlmodels/qqmldelegatemodel.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qmlmodels/qqmldelegatemodel.cpp	2021-11-16 15:55:38.976626527 +0300
@@ -1,6 +1,6 @@
 /****************************************************************************
 **
-** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2020 The Qt Company Ltd.
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the QtQml module of the Qt Toolkit.
@@ -389,6 +389,12 @@
                       q,  QQmlDelegateModel, SLOT(_q_rowsRemoved(QModelIndex,int,int)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
                       q,  QQmlDelegateModel, SLOT(_q_rowsAboutToBeRemoved(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsInserted(QModelIndex,int,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsInserted(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsRemoved(QModelIndex,int,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsRemoved(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsMoved(QModelIndex,int,int,QModelIndex,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsMoved(QModelIndex,int,int,QModelIndex,int)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
                       q, QQmlDelegateModel, SLOT(_q_dataChanged(QModelIndex,QModelIndex,QVector<int>)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
@@ -413,6 +419,12 @@
                         q, SLOT(_q_rowsAboutToBeRemoved(QModelIndex,int,int)));
     QObject::disconnect(aim, SIGNAL(rowsRemoved(QModelIndex,int,int)),
                         q, SLOT(_q_rowsRemoved(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsInserted(QModelIndex,int,int)), q,
+                        SLOT(_q_columnsInserted(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsRemoved(QModelIndex,int,int)), q,
+                        SLOT(_q_columnsRemoved(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsMoved(QModelIndex,int,int,QModelIndex,int)), q,
+                        SLOT(_q_columnsMoved(QModelIndex,int,int,QModelIndex,int)));
     QObject::disconnect(aim, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
                         q, SLOT(_q_dataChanged(QModelIndex,QModelIndex,QVector<int>)));
     QObject::disconnect(aim, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
@@ -1609,7 +1621,7 @@
         removed[i] = 0;
 
     for (const Compositor::Remove &remove : removes) {
-        for (; cacheIndex < remove.cacheIndex; ++cacheIndex)
+        for (; cacheIndex < remove.cacheIndex && cacheIndex < m_cache.size(); ++cacheIndex)
             incrementIndexes(m_cache.at(cacheIndex), m_groupCount, removed);
 
         for (int i = 1; i < m_groupCount; ++i) {
@@ -1953,6 +1965,38 @@
     }
 }
 
+void QQmlDelegateModel::_q_columnsInserted(const QModelIndex &parent, int begin, int end)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if (parent == d->m_adaptorModel.rootIndex && begin == 0) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
+void QQmlDelegateModel::_q_columnsRemoved(const QModelIndex &parent, int begin, int end)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if (parent == d->m_adaptorModel.rootIndex && begin == 0) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
+void QQmlDelegateModel::_q_columnsMoved(const QModelIndex &parent, int start, int end,
+                                        const QModelIndex &destination, int column)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if ((parent == d->m_adaptorModel.rootIndex && start == 0)
+        || (destination == d->m_adaptorModel.rootIndex && column == 0)) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
 void QQmlDelegateModel::_q_dataChanged(const QModelIndex &begin, const QModelIndex &end, const QVector<int> &roles)
 {
     Q_D(QQmlDelegateModel);
@@ -2379,6 +2423,15 @@
         data->ownContext = nullptr;
         data->context = nullptr;
     }
+    /* QTBUG-87228: when destroying object at the application exit, the deferred
+     * parent by setting it to QCoreApplication instance if it's nullptr, so
+     * deletion won't work. Not to leak memory, make sure our object has a that
+     * the parent claims the object at the end of the lifetime. When not at the
+     * application exit, normal event loop will handle the deferred deletion
+     * earlier.
+     */
+    if (object->parent() == nullptr)
+        object->setParent(QCoreApplication::instance());
     object->deleteLater();
 
     if (attached) {
diff -Nuar a/src/qmlmodels/qqmldelegatemodel_p.h b/src/qmlmodels/qqmldelegatemodel_p.h
--- a/src/qmlmodels/qqmldelegatemodel_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qmlmodels/qqmldelegatemodel_p.h	2021-11-16 15:55:38.976626527 +0300
@@ -152,6 +152,9 @@
     void _q_itemsMoved(int from, int to, int count);
     void _q_modelReset();
     void _q_rowsInserted(const QModelIndex &,int,int);
+    void _q_columnsInserted(const QModelIndex &, int, int);
+    void _q_columnsRemoved(const QModelIndex &, int, int);
+    void _q_columnsMoved(const QModelIndex &, int, int, const QModelIndex &, int);
     void _q_rowsAboutToBeRemoved(const QModelIndex &parent, int begin, int end);
     void _q_rowsRemoved(const QModelIndex &,int,int);
     void _q_rowsMoved(const QModelIndex &, int, int, const QModelIndex &, int);
diff -Nuar a/src/qmlmodels/qqmllistmodel.cpp b/src/qmlmodels/qqmllistmodel.cpp
--- a/src/qmlmodels/qqmllistmodel.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qmlmodels/qqmllistmodel.cpp	2021-11-16 15:55:38.977626527 +0300
@@ -703,7 +703,7 @@
         } else if (propertyValue->isNullOrUndefined()) {
             if (reason == SetElement::WasJustInserted) {
                 QQmlError err;
-                auto memberName = propertyName->toString(m_modelCache->engine())->toQString();
+                auto memberName = propertyName->toString(v4)->toQString();
                 err.setDescription(QString::fromLatin1("%1 is %2. Adding an object with a %2 member does not create a role for it.").arg(memberName, propertyValue->isNull() ? QLatin1String("null") : QLatin1String("undefined")));
                 qmlWarning(nullptr, err);
             } else {
diff -Nuar a/src/qmlmodels/qtqmlmodelsglobal_p.h b/src/qmlmodels/qtqmlmodelsglobal_p.h
--- a/src/qmlmodels/qtqmlmodelsglobal_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qmlmodels/qtqmlmodelsglobal_p.h	2021-11-16 15:55:38.977626527 +0300
@@ -59,5 +59,6 @@
 #define Q_QMLMODELS_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
 
 void Q_QMLMODELS_PRIVATE_EXPORT qml_register_types_QtQml_Models();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_Models);
 
 #endif // QTQMLMODELSGLOBAL_P_H
diff -Nuar a/src/qmltyperegistrar/qmltypes.prf b/src/qmltyperegistrar/qmltypes.prf
--- a/src/qmltyperegistrar/qmltypes.prf	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qmltyperegistrar/qmltypes.prf	2021-11-16 15:55:38.977626527 +0300
@@ -44,7 +44,8 @@
 qt_module_deps = $$unique(qt_module_deps)
 
 for(dep, qt_module_deps) {
-    METATYPES_FILENAME = $$lower($$eval(QT.$${dep}.module))_metatypes.json
+    android:ABI = _$${ANDROID_TARGET_ARCH}
+    METATYPES_FILENAME = $$lower($$eval(QT.$${dep}.module))$${ABI}_metatypes.json
     INSTALLED_METATYPES = $$[QT_INSTALL_LIBS]/metatypes/$$METATYPES_FILENAME
     isEmpty(MODULE_BASE_OUTDIR) {
         QML_FOREIGN_METATYPES += $$INSTALLED_METATYPES
diff -Nuar a/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h b/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h
--- a/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h	2021-11-16 15:55:38.977626527 +0300
@@ -58,5 +58,6 @@
 #define Q_QMLWORKERSCRIPT_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
 
 void Q_QMLWORKERSCRIPT_PRIVATE_EXPORT qml_register_types_QtQml_WorkerScript();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_WorkerScript);
 
 #endif // QTQMLWORKERSCRIPTGLOBAL_P_H
diff -Nuar a/src/quick/designer/qquickdesignersupportproperties.cpp b/src/quick/designer/qquickdesignersupportproperties.cpp
--- a/src/quick/designer/qquickdesignersupportproperties.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/designer/qquickdesignersupportproperties.cpp	2021-11-16 15:55:38.978626527 +0300
@@ -137,11 +137,8 @@
     if (inspectedObjects == nullptr)
         inspectedObjects = &localObjectList;
 
-
-    if (inspectedObjects->contains(object))
-        return propertyNameList;
-
-    inspectedObjects->append(object);
+    if (!inspectedObjects->contains(object))
+        inspectedObjects->append(object);
 
     const QMetaObject *metaObject = object->metaObject();
     for (int index = 0; index < metaObject->propertyCount(); ++index) {
@@ -194,12 +191,8 @@
     if (inspectedObjects == nullptr)
         inspectedObjects = &localObjectList;
 
-
-    if (inspectedObjects->contains(object))
-        return propertyNameList;
-
-    inspectedObjects->append(object);
-
+    if (!inspectedObjects->contains(object))
+        inspectedObjects->append(object);
 
     const QMetaObject *metaObject = object->metaObject();
 
diff -Nuar a/src/quick/doc/snippets/qquickview-ex.cpp b/src/quick/doc/snippets/qquickview-ex.cpp
--- a/src/quick/doc/snippets/qquickview-ex.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/doc/snippets/qquickview-ex.cpp	2021-11-16 15:55:38.978626527 +0300
@@ -59,3 +59,12 @@
     return app.exec();
 }
 //![0]
+
+void makeDocTeamHappyByKeepingExampleCompilable() {
+//![1]
+    QScopedPointer<QQuickView> view { new QQuickView };
+    view->setInitialProperties({"x, 100"}, {"width", 50});
+    view->setSource(QUrl::fromLocalFile("myqmlfile.qml"));
+    view->show();
+//![1]
+}
diff -Nuar a/src/quick/handlers/qquickhandlerpoint.cpp b/src/quick/handlers/qquickhandlerpoint.cpp
--- a/src/quick/handlers/qquickhandlerpoint.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/handlers/qquickhandlerpoint.cpp	2021-11-16 15:58:06.198615000 +0300
@@ -82,7 +82,7 @@
 
 void QQuickHandlerPoint::reset()
 {
-    m_id = 0;
+    m_id = -1;
     m_uniqueId = QPointingDeviceUniqueId();
     m_position = QPointF();
     m_scenePosition = QPointF();
@@ -165,7 +165,7 @@
         pressureSum += point.pressure();
         ellipseDiameterSum += point.ellipseDiameters();
     }
-    m_id = 0;
+    m_id = -1;
     m_uniqueId = QPointingDeviceUniqueId();
     // all points are required to be from the same event, so pressed buttons and modifiers should be the same
     m_pressedButtons = points.first().pressedButtons();
diff -Nuar a/src/quick/handlers/qquicksinglepointhandler.cpp b/src/quick/handlers/qquicksinglepointhandler.cpp
--- a/src/quick/handlers/qquicksinglepointhandler.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/handlers/qquicksinglepointhandler.cpp	2021-11-16 15:58:25.358614000 +0300
@@ -75,7 +75,7 @@
     if (!QQuickPointerDeviceHandler::wantsPointerEvent(event))
         return false;
 
-    if (d->pointInfo.id()) {
+    if (d->pointInfo.id() != -1) {
         // We already know which one we want, so check whether it's there.
         // It's expected to be an update or a release.
         // If we no longer want it, cancel the grab.
@@ -125,7 +125,7 @@
             chosen->setAccepted();
         }
     }
-    return d->pointInfo.id();
+    return d->pointInfo.id() != -1;
 }
 
 void QQuickSinglePointHandler::handlePointerEventImpl(QQuickPointerEvent *event)
diff -Nuar a/src/quick/items/qquickitemanimation.cpp b/src/quick/items/qquickitemanimation.cpp
--- a/src/quick/items/qquickitemanimation.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquickitemanimation.cpp	2021-11-16 15:55:38.983626526 +0300
@@ -230,8 +230,8 @@
 {
     Q_D(QQuickParentAnimation);
 
-    QQuickParentAnimationData *data = new QQuickParentAnimationData;
-    QQuickParentAnimationData *viaData = new QQuickParentAnimationData;
+    std::unique_ptr<QQuickParentAnimationData> data(new QQuickParentAnimationData);
+    std::unique_ptr<QQuickParentAnimationData> viaData(new QQuickParentAnimationData);
 
     bool hasExplicit = false;
     if (d->target && d->newParent) {
@@ -377,8 +377,8 @@
         QParallelAnimationGroupJob *ag = new QParallelAnimationGroupJob;
 
         if (d->via)
-            viaAction->setAnimAction(viaData);
-        targetAction->setAnimAction(data);
+            viaAction->setAnimAction(viaData.release());
+        targetAction->setAnimAction(data.release());
 
         //take care of any child animations
         bool valid = d->defaultProperty.isValid();
@@ -405,9 +405,6 @@
             topLevelGroup->appendAnimation(d->via ? viaAction : targetAction);
         }
         return initInstance(topLevelGroup);
-    } else {
-        delete data;
-        delete viaData;
     }
     return nullptr;
 }
diff -Nuar a/src/quick/items/qquickitem.cpp b/src/quick/items/qquickitem.cpp
--- a/src/quick/items/qquickitem.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquickitem.cpp	2021-11-16 15:55:38.982626526 +0300
@@ -1,9 +1,9 @@
 /****************************************************************************
 **
-** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2021 The Qt Company Ltd.
 ** Contact: https://www.qt.io/licensing/
 **
-** This file is part of the QtQuick module of the Qt Toolkit.
+** This file is part of the QtQuick module of the Qt Toolkit.fset
 **
 ** $QT_BEGIN_LICENSE:LGPL$
 ** Commercial License Usage
@@ -1883,7 +1883,23 @@
     \endqml
 
 
-    \section2 Key Handling
+    \section2 Event Handling
+
+    All Item-based visual types can use \l {Qt Quick Input Handlers}{Input Handlers}
+    to handle incoming input events (subclasses of QInputEvent), such as mouse,
+    touch and key events. This is the preferred declarative way to handle events.
+
+    An alternative way to handle touch events is to subclass QQuickItem, call
+    setAcceptTouchEvents() in the constructor, and override touchEvent().
+    \l {QEvent::setAccepted()}{Accept} the entire event to stop delivery to
+    items underneath, and to exclusively grab all the event's touch points.
+
+    Likewise, a QQuickItem subclass can call setAcceptedMouseButtons()
+    to register to receive mouse button events, setAcceptHoverEvents()
+    to receive hover events (mouse movements while no button is pressed),
+    and override the virtual functions mousePressEvent(), mouseMoveEvent(), and
+    mouseReleaseEvent(). Those can also accept the event to prevent further
+    delivery and get an implicit grab at the same time.
 
     Key handling is available to all Item-based visual types via the \l Keys
     attached property.  The \e Keys attached property provides basic signals
@@ -3753,6 +3769,14 @@
         emit widthChanged();
     if (change.heightChange())
         emit heightChanged();
+#if QT_CONFIG(accessibility)
+    if (QAccessible::isActive()) {
+        if (QObject *acc = QQuickAccessibleAttached::findAccessible(this)) {
+            QAccessibleEvent ev(acc, QAccessible::LocationChanged);
+            QAccessible::updateAccessibility(&ev);
+        }
+    }
+#endif
 }
 
 /*!
@@ -7293,7 +7317,9 @@
     If an item does not accept the mouse button for a particular mouse event,
     the mouse event will not be delivered to the item and will be delivered
     to the next item in the item hierarchy instead.
-  */
+
+    \sa acceptTouchEvents()
+*/
 Qt::MouseButtons QQuickItem::acceptedMouseButtons() const
 {
     Q_D(const QQuickItem);
@@ -7302,7 +7328,13 @@
 
 /*!
     Sets the mouse buttons accepted by this item to \a buttons.
-  */
+
+    \note In Qt 5, calling setAcceptedMouseButtons() implicitly caused
+    an item to receive touch events as well as mouse events; but it was
+    recommended to call setAcceptTouchEvents() to subscribe for them.
+    In Qt 6, it is necessary to call setAcceptTouchEvents() to continue
+    to receive them.
+*/
 void QQuickItem::setAcceptedMouseButtons(Qt::MouseButtons buttons)
 {
     Q_D(QQuickItem);
diff -Nuar a/src/quick/items/qquickloader.cpp b/src/quick/items/qquickloader.cpp
--- a/src/quick/items/qquickloader.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquickloader.cpp	2021-11-16 15:55:38.983626526 +0300
@@ -738,6 +738,9 @@
         return;
     }
 
+    if (!active)
+        return;
+
     QQmlContext *creationContext = component->creationContext();
     if (!creationContext) creationContext = qmlContext(q);
     itemContext = new QQmlContext(creationContext);
diff -Nuar a/src/quick/items/qquickmousearea_p_p.h b/src/quick/items/qquickmousearea_p_p.h
--- a/src/quick/items/qquickmousearea_p_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquickmousearea_p_p.h	2021-11-16 15:55:38.983626526 +0300
@@ -61,7 +61,6 @@
 
 class QQuickMouseEvent;
 class QQuickMouseArea;
-class QQuickPointerMask;
 class QQuickMouseAreaPrivate : public QQuickItemPrivate
 {
     Q_DECLARE_PUBLIC(QQuickMouseArea)
@@ -100,7 +99,6 @@
 #if QT_CONFIG(quick_draganddrop)
     QQuickDrag *drag;
 #endif
-    QPointer<QQuickPointerMask> mask;
     QPointF startScene;
     QPointF targetStartPos;
     QPointF lastPos;
diff -Nuar a/src/quick/items/qquickshadereffectsource.cpp b/src/quick/items/qquickshadereffectsource.cpp
--- a/src/quick/items/qquickshadereffectsource.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquickshadereffectsource.cpp	2021-11-16 15:55:38.983626526 +0300
@@ -344,7 +344,6 @@
             d->refFromEffectItem(m_hideSource);
             d->addItemChangeListener(this, QQuickItemPrivate::Geometry);
             connect(m_sourceItem, SIGNAL(destroyed(QObject*)), this, SLOT(sourceItemDestroyed(QObject*)));
-            connect(m_sourceItem, SIGNAL(parentChanged(QQuickItem*)), this, SLOT(sourceItemParentChanged(QQuickItem*)));
         } else {
             qWarning("ShaderEffectSource: sourceItem and ShaderEffectSource must both be children of the same window.");
             m_sourceItem = nullptr;
@@ -364,13 +363,6 @@
 }
 
 
-void QQuickShaderEffectSource::sourceItemParentChanged(QQuickItem *parent)
-{
-    if (!parent && m_texture)
-        m_texture->setItem(0);
-}
-
-
 /*!
     \qmlproperty rect QtQuick::ShaderEffectSource::sourceRect
 
diff -Nuar a/src/quick/items/qquickshadereffectsource_p.h b/src/quick/items/qquickshadereffectsource_p.h
--- a/src/quick/items/qquickshadereffectsource_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquickshadereffectsource_p.h	2021-11-16 15:55:38.984626526 +0300
@@ -173,7 +173,6 @@
 private Q_SLOTS:
     void sourceItemDestroyed(QObject *item);
     void invalidateSceneGraph();
-    void sourceItemParentChanged(QQuickItem *parent);
 
 protected:
     void releaseResources() override;
diff -Nuar a/src/quick/items/qquicktableview.cpp b/src/quick/items/qquicktableview.cpp
--- a/src/quick/items/qquicktableview.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquicktableview.cpp	2021-11-16 15:55:38.984626526 +0300
@@ -1760,11 +1760,8 @@
         const auto syncView_d = syncView->d_func();
 
         if (syncView_d->loadedItems.isEmpty()) {
-            // The sync view contains no loaded items. This probably means
-            // that it has not been rebuilt yet. Which also means that
-            // we cannot rebuild anything before this happens.
-            topLeftCell.rx() = kEdgeIndexNotSet;
-            topLeftCell.ry() = kEdgeIndexNotSet;
+            topLeftCell.rx() = 0;
+            topLeftCell.ry() = 0;
             return;
         }
 
diff -Nuar a/src/quick/items/qquicktext.cpp b/src/quick/items/qquicktext.cpp
--- a/src/quick/items/qquicktext.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquicktext.cpp	2021-11-16 15:55:38.985626526 +0300
@@ -398,6 +398,8 @@
         layedOutTextRect = QRectF(0, 0, 0, fontHeight);
         advance = QSizeF();
         signalSizeChange(previousSize);
+        lineCount = 1;
+        emit q->lineCountChanged();
         updateType = UpdatePaintNode;
         q->update();
         return;
@@ -2166,7 +2168,7 @@
     <img src="" align="top,middle,bottom" width="" height=""> - inline images
     <ol type="">, <ul type=""> and <li> - ordered and unordered lists
     <pre></pre> - preformatted
-    &gt; &lt; &amp;
+    &gt; &lt; &amp; &quot; &nbsp; &apos;
     \endcode
 
     \c Text.StyledText parser is strict, requiring tags to be correctly nested.
diff -Nuar a/src/quick/items/qquicktextinput.cpp b/src/quick/items/qquicktextinput.cpp
--- a/src/quick/items/qquicktextinput.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquicktextinput.cpp	2021-11-16 15:55:38.986626526 +0300
@@ -3831,8 +3831,7 @@
     int delimiter = maskFields.indexOf(QLatin1Char(';'));
     if (maskFields.isEmpty() || delimiter == 0) {
         if (m_maskData) {
-            delete [] m_maskData;
-            m_maskData = nullptr;
+            m_maskData.reset(nullptr);
             m_maxLength = 32767;
             internalSetText(QString());
         }
@@ -3863,8 +3862,7 @@
             m_maxLength++;
     }
 
-    delete [] m_maskData;
-    m_maskData = new MaskInputData[m_maxLength];
+    m_maskData.reset(new MaskInputData[m_maxLength]);
 
     MaskInputData::Casemode m = MaskInputData::NoCaseMode;
     c = 0;
diff -Nuar a/src/quick/items/qquicktextinput_p_p.h b/src/quick/items/qquicktextinput_p_p.h
--- a/src/quick/items/qquicktextinput_p_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquicktextinput_p_p.h	2021-11-16 15:55:38.986626526 +0300
@@ -58,6 +58,8 @@
 
 #include "qplatformdefs.h"
 
+#include <memory>
+
 //
 //  W A R N I N G
 //  -------------
@@ -230,7 +232,7 @@
 
     QQuickItem *cursorItem;
     QQuickTextNode *textNode;
-    MaskInputData *m_maskData;
+    std::unique_ptr<MaskInputData[]> m_maskData;
     QInputControl *m_inputControl;
 
     QList<int> m_transactions;
diff -Nuar a/src/quick/items/qquickview.cpp b/src/quick/items/qquickview.cpp
--- a/src/quick/items/qquickview.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquickview.cpp	2021-11-16 15:55:38.987626526 +0300
@@ -240,7 +240,11 @@
    Sets the initial properties \a initialProperties with which the QML
    component gets initialized after calling \l QQuickView::setSource().
 
+   \snippet qquickview-ex.cpp 1
+
    \note You can only use this function to initialize top-level properties.
+   \note This function should always be called before setSource, as it has
+   no effect once the component has become \c Ready.
 
    \sa QQmlComponent::createWithInitialProperties()
    \since 5.14
diff -Nuar a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp
--- a/src/quick/items/qquickwindow.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/items/qquickwindow.cpp	2021-11-16 15:55:38.988626526 +0300
@@ -450,15 +450,14 @@
 void QQuickWindow::handleScreenChanged(QScreen *screen)
 {
     Q_D(QQuickWindow);
+    disconnect(d->physicalDpiChangedConnection);
     if (screen) {
         physicalDpiChanged();
         // When physical DPI changes on the same screen, either the resolution or the device pixel
         // ratio changed. We must check what it is. Device pixel ratio does not have its own
         // ...Changed() signal.
-        d->physicalDpiChangedConnection = connect(screen, SIGNAL(physicalDotsPerInchChanged(qreal)),
-                                                  this, SLOT(physicalDpiChanged()));
-    } else {
-        disconnect(d->physicalDpiChangedConnection);
+        d->physicalDpiChangedConnection = connect(screen, &QScreen::physicalDotsPerInchChanged,
+                                                  this, &QQuickWindow::physicalDpiChanged);
     }
 
     d->forcePolish();
@@ -2864,6 +2863,14 @@
 {
     Q_Q(QQuickWindow);
     QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+#if defined(Q_OS_ANDROID) && QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+    // QTBUG-85379
+    // In QT_VERSION below 6.0.0 touchEnabled for QtQuickItems is set by default to true
+    // It causes delivering touch events to Items which are not interested
+    // In some cases (like using Material Style in Android) it may cause a crash
+    if (itemPrivate->wasDeleted)
+        return;
+#endif
     pointerEvent->localize(item);
 
     // Let the Item's handlers (if any) have the event first.
diff -Nuar a/src/quick/qtquickglobal_p.h b/src/quick/qtquickglobal_p.h
--- a/src/quick/qtquickglobal_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/qtquickglobal_p.h	2021-11-16 15:55:38.988626526 +0300
@@ -62,6 +62,7 @@
 #define Q_QUICK_PRIVATE_EXPORT Q_QUICK_EXPORT
 
 void Q_QUICK_PRIVATE_EXPORT qml_register_types_QtQuick();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick);
 
 QT_BEGIN_NAMESPACE
 
diff -Nuar a/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp b/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
--- a/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp	2021-11-16 15:55:38.989626526 +0300
@@ -428,6 +428,18 @@
                       QStringLiteral(":/qt-project.org/scenegraph/shaders_ng/textmask.frag.qsb"));
 }
 
+enum UbufOffset {
+    ModelViewMatrixOffset = 0,
+    ProjectionMatrixOffset = ModelViewMatrixOffset + 64,
+    ColorOffset = ProjectionMatrixOffset + 64,
+    TextureScaleOffset = ColorOffset + 16,
+    DprOffset = TextureScaleOffset + 8,
+
+    // + 1 float padding (vec4 must be aligned to 16)
+    StyleColorOffset = DprOffset + 4 + 4,
+    ShiftOffset = StyleColorOffset + 16
+};
+
 bool QSGTextMaskRhiShader::updateUniformData(RenderState &state,
                                              QSGMaterial *newMaterial, QSGMaterial *oldMaterial)
 {
@@ -443,11 +455,14 @@
 
     bool changed = false;
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= DprOffset + 4);
 
     if (state.isMatrixDirty()) {
-        const QMatrix4x4 m = state.combinedMatrix();
-        memcpy(buf->data(), m.constData(), 64);
+        const QMatrix4x4 mv = state.modelViewMatrix();
+        memcpy(buf->data() + ModelViewMatrixOffset, mv.constData(), 64);
+        const QMatrix4x4 p = state.projectionMatrix();
+        memcpy(buf->data() + ProjectionMatrixOffset, p.constData(), 64);
+
         changed = true;
     }
 
@@ -456,13 +471,13 @@
     if (updated || !oldMat || oldRtex != newRtex) {
         const QVector2D textureScale = QVector2D(1.0f / mat->rhiGlyphCache()->width(),
                                                  1.0f / mat->rhiGlyphCache()->height());
-        memcpy(buf->data() + 64 + 16, &textureScale, 8);
+        memcpy(buf->data() + TextureScaleOffset, &textureScale, 8);
         changed = true;
     }
 
     if (!oldMat) {
         float dpr = state.devicePixelRatio();
-        memcpy(buf->data() + 64 + 16 + 8, &dpr, 4);
+        memcpy(buf->data() + DprOffset, &dpr, 4);
     }
 
     // move texture uploads/copies onto the renderer's soon-to-be-committed list
@@ -510,11 +525,11 @@
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 80);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         const QVector4D color = qsg_premultiply(mat->color(), state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -553,12 +568,12 @@
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         // shader takes vec4 but uses alpha only; coloring happens via the blend constant
         const QVector4D color = qsg_premultiply(mat->color(), state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -608,12 +623,12 @@
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         // shader takes vec4 but uses alpha only
         const QVector4D color(0, 0, 0, mat->color().w() * state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -649,20 +664,17 @@
     QSGStyledTextMaterial *oldMat = static_cast<QSGStyledTextMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 120);
-
-    // matrix..dpr + 1 float padding (vec4 must be aligned to 16)
-    const int startOffset = 64 + 16 + 8 + 4 + 4;
+    Q_ASSERT(buf->size() >= ShiftOffset + 8);
 
     if (oldMat == nullptr || mat->styleColor() != oldMat->styleColor() || state.isOpacityDirty()) {
         const QVector4D styleColor = qsg_premultiply(mat->styleColor(), state.opacity());
-        memcpy(buf->data() + startOffset, &styleColor, 16);
+        memcpy(buf->data() + StyleColorOffset, &styleColor, 16);
         changed = true;
     }
 
     if (oldMat == nullptr || oldMat->styleShift() != mat->styleShift()) {
         const QVector2D v = mat->styleShift();
-        memcpy(buf->data() + startOffset + 16, &v, 8);
+        memcpy(buf->data() + ShiftOffset, &v, 8);
         changed = true;
     }
 
diff -Nuar a/src/quick/scenegraph/shaders_ng/24bittextmask.frag b/src/quick/scenegraph/shaders_ng/24bittextmask.frag
--- a/src/quick/scenegraph/shaders_ng/24bittextmask.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/24bittextmask.frag	2021-11-16 15:55:38.989626526 +0300
@@ -6,8 +6,9 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
-    vec4 color; // only alpha is used, but must be vec4 due to layout compat
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
+    vec4 color;
     vec2 textureScale;
     float dpr;
 } ubuf;
diff -Nuar a/src/quick/scenegraph/shaders_ng/32bitcolortext.frag b/src/quick/scenegraph/shaders_ng/32bitcolortext.frag
--- a/src/quick/scenegraph/shaders_ng/32bitcolortext.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/32bitcolortext.frag	2021-11-16 15:55:38.989626526 +0300
@@ -6,8 +6,9 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
-    vec4 color; // only alpha is used, but must be vec4 due to layout compat
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
+    vec4 color;
     vec2 textureScale;
     float dpr;
 } ubuf;
diff -Nuar a/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag b/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag
--- a/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag	2021-11-16 15:55:38.989626526 +0300
@@ -6,7 +6,8 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff -Nuar a/src/quick/scenegraph/shaders_ng/8bittextmask.frag b/src/quick/scenegraph/shaders_ng/8bittextmask.frag
--- a/src/quick/scenegraph/shaders_ng/8bittextmask.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/8bittextmask.frag	2021-11-16 15:55:38.989626526 +0300
@@ -6,7 +6,8 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff -Nuar a/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag b/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag
--- a/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag	2021-11-16 15:55:38.990626526 +0300
@@ -11,11 +11,12 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
diff -Nuar a/src/quick/scenegraph/shaders_ng/outlinedtext.frag b/src/quick/scenegraph/shaders_ng/outlinedtext.frag
--- a/src/quick/scenegraph/shaders_ng/outlinedtext.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext.frag	2021-11-16 15:55:38.989626526 +0300
@@ -11,11 +11,12 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
diff -Nuar a/src/quick/scenegraph/shaders_ng/outlinedtext.vert b/src/quick/scenegraph/shaders_ng/outlinedtext.vert
--- a/src/quick/scenegraph/shaders_ng/outlinedtext.vert	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext.vert	2021-11-16 15:55:38.990626526 +0300
@@ -10,11 +10,12 @@
 layout(location = 4) out vec2 sCoordRight;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
@@ -28,6 +29,6 @@
      sCoordDown = (tCoord - vec2(0.0, 1.0)) * ubuf.textureScale;
      sCoordLeft = (tCoord - vec2(-1.0, 0.0)) * ubuf.textureScale;
      sCoordRight = (tCoord - vec2(1.0, 0.0)) * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff -Nuar a/src/quick/scenegraph/shaders_ng/styledtext_a.frag b/src/quick/scenegraph/shaders_ng/styledtext_a.frag
--- a/src/quick/scenegraph/shaders_ng/styledtext_a.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/styledtext_a.frag	2021-11-16 15:55:38.990626526 +0300
@@ -8,7 +8,8 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff -Nuar a/src/quick/scenegraph/shaders_ng/styledtext.frag b/src/quick/scenegraph/shaders_ng/styledtext.frag
--- a/src/quick/scenegraph/shaders_ng/styledtext.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/styledtext.frag	2021-11-16 15:55:38.990626526 +0300
@@ -8,7 +8,8 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff -Nuar a/src/quick/scenegraph/shaders_ng/styledtext.vert b/src/quick/scenegraph/shaders_ng/styledtext.vert
--- a/src/quick/scenegraph/shaders_ng/styledtext.vert	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/styledtext.vert	2021-11-16 15:55:38.990626526 +0300
@@ -7,7 +7,8 @@
 layout(location = 1) out vec2 shiftedSampleCoord;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
@@ -22,6 +23,6 @@
 {
      sampleCoord = tCoord * ubuf.textureScale;
      shiftedSampleCoord = (tCoord - ubuf.shift) * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff -Nuar a/src/quick/scenegraph/shaders_ng/textmask.frag b/src/quick/scenegraph/shaders_ng/textmask.frag
--- a/src/quick/scenegraph/shaders_ng/textmask.frag	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/textmask.frag	2021-11-16 15:55:38.990626526 +0300
@@ -6,7 +6,8 @@
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff -Nuar a/src/quick/scenegraph/shaders_ng/textmask.vert b/src/quick/scenegraph/shaders_ng/textmask.vert
--- a/src/quick/scenegraph/shaders_ng/textmask.vert	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/scenegraph/shaders_ng/textmask.vert	2021-11-16 15:55:38.990626526 +0300
@@ -6,7 +6,8 @@
 layout(location = 0) out vec2 sampleCoord;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
@@ -17,6 +18,6 @@
 void main()
 {
      sampleCoord = tCoord * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff -Nuar a/src/quick/util/qquickstate.cpp b/src/quick/util/qquickstate.cpp
--- a/src/quick/util/qquickstate.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/util/qquickstate.cpp	2021-11-16 15:55:38.991626526 +0300
@@ -635,6 +635,11 @@
             }
         }
         if (!found) {
+            // If revert list contains bindings assigned to deleted objects, we need to
+            // prevent reverting properties of those objects.
+            if (d->revertList.at(ii).binding() && !d->revertList.at(ii).property().object()) {
+                continue;
+            }
             QVariant cur = d->revertList.at(ii).property().read();
             QQmlPropertyPrivate::removeBinding(d->revertList.at(ii).property());
 
diff -Nuar a/src/quick/util/qquickstyledtext.cpp b/src/quick/util/qquickstyledtext.cpp
--- a/src/quick/util/qquickstyledtext.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quick/util/qquickstyledtext.cpp	2021-11-16 15:55:38.991626526 +0300
@@ -46,6 +46,8 @@
 #include "qquickstyledtext_p.h"
 #include <QQmlContext>
 
+Q_LOGGING_CATEGORY(lcStyledText, "qt.quick.styledtext")
+
 /*
     QQuickStyledText supports few tags:
 
@@ -562,10 +564,14 @@
                 textOut += QChar(60);
             else if (entity == QLatin1String("amp"))
                 textOut += QChar(38);
+            else if (entity == QLatin1String("apos"))
+                textOut += QChar(39);
             else if (entity == QLatin1String("quot"))
                 textOut += QChar(34);
             else if (entity == QLatin1String("nbsp"))
                 textOut += QChar(QChar::Nbsp);
+            else
+                qCWarning(lcStyledText) << "StyledText doesn't support entity" << entity;
             return;
         } else if (*ch == QLatin1Char(' ')) {
             QStringRef entity(&textIn, entityStart - 1, entityLength + 1);
diff -Nuar a/src/quickshapes/qquickshapesglobal_p.h b/src/quickshapes/qquickshapesglobal_p.h
--- a/src/quickshapes/qquickshapesglobal_p.h	2020-10-27 11:02:12.000000000 +0300
+++ b/src/quickshapes/qquickshapesglobal_p.h	2021-11-16 15:55:38.991626526 +0300
@@ -51,6 +51,7 @@
 // We mean it.
 //
 
+#include <QtQml/qqmlextensionplugin.h>
 #include "qquickshapesglobal.h"
 
 QT_BEGIN_NAMESPACE
@@ -60,5 +61,6 @@
 QT_END_NAMESPACE
 
 void Q_QUICKSHAPES_PRIVATE_EXPORT qml_register_types_QtQuick_Shapes();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Shapes);
 
 #endif // QQUICKSHAPESGLOBAL_P_H
diff -Nuar a/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp b/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp
--- a/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp	2021-11-16 15:55:38.992626526 +0300
@@ -910,19 +910,25 @@
     component.setData("import QtQml 2.12\n"
                       "QtObject {\n"
                       "    id: root\n"
-                      "    property string result\n"
+                      "    property string result: 'unset'\n"
+                      "    property string resultCallbackInternal: 'unset'\n"
+                      "    property string resultCallbackExternal: 'unset'\n"
                       "    signal signalWithArg(string textArg)\n"
+                      "    function call(callback) { callback(); }\n"
+                      "    function externalCallback() { root.resultCallbackExternal = textArg; }\n"
                       "    property Connections connections : Connections {\n"
                       "        target: root\n"
-                      "        onSignalWithArg: { root.result = textArg; }\n"
+                      "        onSignalWithArg: { root.result = textArg; call(function() { root.resultCallbackInternal = textArg; }); call(externalCallback); }\n"
                       "    }\n"
                       "    Component.onCompleted: signalWithArg('something')\n"
                       "}", QUrl("test.qml"));
 
-    QVERIFY(component.isReady());
+    QVERIFY2(component.isReady(), qPrintable(component.errorString()));
     QScopedPointer<QObject> obj(component.create());
     QVERIFY(obj);
     QCOMPARE(obj->property("result").toString(), QLatin1String("something"));
+    QCOMPARE(obj->property("resultCallbackInternal").toString(), QLatin1String("something"));
+    QCOMPARE(obj->property("resultCallbackExternal").toString(), QLatin1String("unset"));
 }
 
 QTEST_MAIN(tst_qv4debugger)
diff -Nuar a/tests/auto/qml/qjsengine/tst_qjsengine.cpp b/tests/auto/qml/qjsengine/tst_qjsengine.cpp
--- a/tests/auto/qml/qjsengine/tst_qjsengine.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/qml/qjsengine/tst_qjsengine.cpp	2021-11-16 15:55:38.993626526 +0300
@@ -102,6 +102,7 @@
     void valueConversion_RegularExpression();
     void castWithMultipleInheritance();
     void collectGarbage();
+    void collectGarbageNestedWrappersTwoEngines();
     void gcWithNestedDataStructure();
     void stacktrace();
     void numberParsing_data();
@@ -1809,6 +1810,44 @@
     QVERIFY(ptr.isNull());
 }
 
+class TestObjectContainer : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QObject *dummy MEMBER m_dummy CONSTANT)
+
+public:
+    TestObjectContainer() : m_dummy(new QObject(this)) {}
+
+private:
+    QObject *m_dummy;
+};
+
+void tst_QJSEngine::collectGarbageNestedWrappersTwoEngines()
+{
+    QJSEngine engine1;
+    QJSEngine engine2;
+
+    TestObjectContainer container;
+    QQmlEngine::setObjectOwnership(&container, QQmlEngine::CppOwnership);
+
+    engine1.globalObject().setProperty("foobar", engine1.newQObject(&container));
+    engine2.globalObject().setProperty("foobar", engine2.newQObject(&container));
+
+    engine1.evaluate("foobar.dummy.baz = 42");
+    engine2.evaluate("foobar.dummy.baz = 43");
+
+    QCOMPARE(engine1.evaluate("foobar.dummy.baz").toInt(), 42);
+    QCOMPARE(engine2.evaluate("foobar.dummy.baz").toInt(), 43);
+
+    engine1.collectGarbage();
+    engine2.collectGarbage();
+
+    // The GC should not collect dummy object wrappers neither in engine1 nor engine2, we
+    // verify that by checking whether the baz property still has its previous value.
+    QCOMPARE(engine1.evaluate("foobar.dummy.baz").toInt(), 42);
+    QCOMPARE(engine2.evaluate("foobar.dummy.baz").toInt(), 43);
+}
+
 void tst_QJSEngine::gcWithNestedDataStructure()
 {
     // The GC must be able to traverse deeply nested objects, otherwise this
diff -Nuar a/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml b/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml
--- a/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml	2021-11-16 15:55:38.993626526 +0300
@@ -0,0 +1,11 @@
+import QtQuick 2.8
+
+ListView {
+    id: root
+    width: 200
+    height: 200
+
+    delegate: Text {
+        text: display
+    }
+}
diff -Nuar a/tests/auto/qml/qqmldelegatemodel/qqmldelegatemodel.pro b/tests/auto/qml/qqmldelegatemodel/qqmldelegatemodel.pro
--- a/tests/auto/qml/qqmldelegatemodel/qqmldelegatemodel.pro	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/qml/qqmldelegatemodel/qqmldelegatemodel.pro	2021-11-16 15:55:38.993626526 +0300
@@ -2,7 +2,7 @@
 TARGET = tst_qqmldelegatemodel
 macos:CONFIG -= app_bundle
 
-QT += qml testlib core-private qml-private qmlmodels-private
+QT += qml quick testlib core-private qml-private qmlmodels-private
 
 SOURCES += tst_qqmldelegatemodel.cpp
 
diff -Nuar a/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp b/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp
--- a/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp	2021-11-16 15:55:38.993626526 +0300
@@ -27,8 +27,12 @@
 ****************************************************************************/
 
 #include <QtTest/qtest.h>
+#include <QtCore/QConcatenateTablesProxyModel>
+#include <QtGui/QStandardItemModel>
 #include <QtQml/qqmlcomponent.h>
 #include <QtQmlModels/private/qqmldelegatemodel_p.h>
+#include <QtQuick/qquickview.h>
+#include <QtQuick/qquickitem.h>
 
 #include "../../shared/util.h"
 
@@ -42,6 +46,7 @@
 private slots:
     void valueWithoutCallingObjectFirst_data();
     void valueWithoutCallingObjectFirst();
+    void redrawUponColumnChange();
 };
 
 class AbstractItemModel : public QAbstractItemModel
@@ -134,6 +139,30 @@
     QCOMPARE(model->variantValue(index, role), expectedValue);
 }
 
+void tst_QQmlDelegateModel::redrawUponColumnChange()
+{
+    QStandardItemModel m1;
+    m1.appendRow({
+            new QStandardItem("Banana"),
+            new QStandardItem("Coconut"),
+    });
+
+    QQuickView view(testFileUrl("redrawUponColumnChange.qml"));
+    QCOMPARE(view.status(), QQuickView::Ready);
+    view.show();
+    QQuickItem *root = view.rootObject();
+    root->setProperty("model", QVariant::fromValue<QObject *>(&m1));
+
+    QObject *item = root->property("currentItem").value<QObject *>();
+    QVERIFY(item);
+    QCOMPARE(item->property("text").toString(), "Banana");
+
+    QVERIFY(root);
+    m1.removeColumn(0);
+
+    QCOMPARE(item->property("text").toString(), "Coconut");
+}
+
 QTEST_MAIN(tst_QQmlDelegateModel)
 
 #include "tst_qqmldelegatemodel.moc"
diff -Nuar a/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml b/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml
--- a/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml	2021-11-16 15:55:38.993626526 +0300
@@ -0,0 +1,29 @@
+import QtQml 2
+
+QtObject {
+  id: root
+  property int sum
+  Component.onCompleted: {
+    const target = { prop1: 1, prop2: 2, prop3: 3 };
+    const handler = {
+      get: function(target, key) {
+        return target[key]+1;
+      },
+      ownKeys: function() {
+        return ["prop1", "prop3"];
+      },
+      getOwnPropertyDescriptor: function(target, key) {
+        return {
+          value: this.get(target, key),
+          enumerable: true,
+          configurable: true
+        };
+      }
+    };
+    const proxy = new Proxy(target, handler);
+    for (var prop in proxy) {
+      root.sum += proxy[prop] // prop2 gets skipped, the values of 1 and 3 get incremented
+    }
+    // so root.sum should be 6 now
+  }
+}
diff -Nuar a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
--- a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp	2021-11-16 15:55:38.996626525 +0300
@@ -382,7 +382,8 @@
     void semicolonAfterProperty();
     void hugeStack();
     void variantConversionMethod();
-
+    void proxyIteration();
+    void proxyHandlerTraps();
     void gcCrashRegressionTest();
 
 private:
@@ -9306,6 +9307,44 @@
     QCOMPARE(obj.funcCalled, QLatin1String("QModelIndex"));
 }
 
+void tst_qqmlecmascript::proxyIteration()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine, testFileUrl("proxyIteration.qml"));
+    QScopedPointer<QObject> root(component.create());
+    QVERIFY2(root != nullptr, qPrintable(component.errorString()));
+    QCOMPARE(root->property("sum").toInt(), 6);
+}
+
+void tst_qqmlecmascript::proxyHandlerTraps()
+{
+    const QString expression = QStringLiteral(R"SNIPPET(
+        (function(){
+            const target = {
+                prop: 47
+            };
+            const handler = {
+                getOwnPropertyDescriptor(target, prop) {
+                    return { configurable: true, enumerable: true, value: 47 };
+                }
+            };
+            const proxy = new Proxy(target, handler);
+
+            // QTBUG-88786
+            if (!proxy.propertyIsEnumerable("prop"))
+                throw Error("FAIL: propertyisEnumerable");
+            if (!proxy.hasOwnProperty("prop"))
+                throw Error("FAIL: hasOwnProperty");
+
+            return "SUCCESS";
+        })()
+    )SNIPPET");
+
+    QJSEngine engine;
+    QJSValue value = engine.evaluate(expression);
+    QVERIFY(value.isString() && value.toString() == QStringLiteral("SUCCESS"));
+}
+
 QTEST_MAIN(tst_qqmlecmascript)
 
 #include "tst_qqmlecmascript.moc"
diff -Nuar a/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml b/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml
--- a/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml	2021-11-16 15:55:38.996626525 +0300
@@ -0,0 +1,11 @@
+import QtQml 2.15
+
+QtObject {
+    component IC : QtObject {
+        property string name
+        property int age
+    }
+
+    property IC other: IC { name: "Toby"; age: 30 }
+    property list<IC> listProp: [IC { name: "Alfred Ill"; age: 65 }, IC { name: "Claire Zachanassian"; age: 62}]
+}
diff -Nuar a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
--- a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp	2021-11-16 15:55:38.997626525 +0300
@@ -5604,6 +5604,7 @@
     QTest::newRow("Alias resolves correctly") << testFileUrl("inlineComponentWithAlias.qml") << QColorConstants::Svg::lime << 42 << true;
 
     QTest::newRow("Two inline components in same do not crash (QTBUG-86989)") << testFileUrl("twoInlineComponents.qml") << QColor() << 0 << false;
+    QTest::newRow("Inline components used in same file (QTBUG-89173)") << testFileUrl("inlineComponentsSameFile.qml") << QColor() << 0 << false;
 }
 
 void tst_qqmllanguage::inlineComponentReferenceCycle_data()
diff -Nuar a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
--- a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp	2021-11-16 15:55:38.998626525 +0300
@@ -130,6 +130,7 @@
     void dynamic_roles_crash_QTBUG_38907();
     void nestedListModelIteration();
     void undefinedAppendShouldCauseError();
+    void nullPropertyCrash();
 };
 
 bool tst_qqmllistmodel::compareVariantList(const QVariantList &testList, QVariant object)
@@ -1723,6 +1724,27 @@
     QScopedPointer<QObject>(component.create());
 }
 
+// QTBUG-89173
+void tst_qqmllistmodel::nullPropertyCrash()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.setData(
+            R"(import QtQuick 2.15
+            ListView {
+                model: ListModel { id: listModel }
+
+                delegate: Item {}
+
+                Component.onCompleted: {
+                    listModel.append({"a": "value1", "b":[{"c":"value2"}]})
+                    listModel.append({"a": "value2", "b":[{"c":null}]})
+                }
+            })",
+            QUrl());
+    QTest::ignoreMessage(QtMsgType::QtWarningMsg, "<Unknown File>: c is null. Adding an object with a null member does not create a role for it.");
+    QScopedPointer<QObject>(component.create());
+}
 
 QTEST_MAIN(tst_qqmllistmodel)
 
diff -Nuar a/tests/auto/qml/qv4mm/tst_qv4mm.cpp b/tests/auto/qml/qv4mm/tst_qv4mm.cpp
--- a/tests/auto/qml/qv4mm/tst_qv4mm.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/qml/qv4mm/tst_qv4mm.cpp	2021-11-16 15:55:38.998626525 +0300
@@ -76,10 +76,10 @@
         QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 1);
         QCOMPARE(engine2.memoryManager->m_pendingFreedObjectWrapperValue.size(), 0);
 
-        // Moves the additional WeakValue from m_multiplyWrappedQObjects to
-        // m_pendingFreedObjectWrapperValue. It's still alive after all.
+        // The additional WeakValue from m_multiplyWrappedQObjects hasn't been moved
+        // to m_pendingFreedObjectWrapperValue yet. It's still alive after all.
         engine1.memoryManager->runGC();
-        QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 2);
+        QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 1);
 
         // engine2 doesn't own the object as engine1 was the first to wrap it above.
         // Therefore, no effect here.
diff -Nuar a/tests/auto/quick/qquickloader/data/loader-async-race.qml b/tests/auto/quick/qquickloader/data/loader-async-race.qml
--- a/tests/auto/quick/qquickloader/data/loader-async-race.qml	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/quick/qquickloader/data/loader-async-race.qml	2021-11-16 15:55:38.998626525 +0300
@@ -0,0 +1,14 @@
+import QtQuick 2.15
+
+Item {
+    id: root
+    Component.onCompleted: {
+        myloader.active = false
+    }
+    Loader {
+        id: myloader
+        anchors.fill: parent
+        asynchronous: true
+        source: "loader-async-race-rect.qml"
+    }
+}
diff -Nuar a/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml b/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml
--- a/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml	2021-11-16 15:55:38.998626525 +0300
@@ -0,0 +1,10 @@
+import QtQuick 2.15
+
+Rectangle {
+    anchors.fill: parent
+    color: "blue"
+    Item {
+        Item {
+        }
+    }
+}
diff -Nuar a/tests/auto/quick/qquickloader/tst_qquickloader.cpp b/tests/auto/quick/qquickloader/tst_qquickloader.cpp
--- a/tests/auto/quick/qquickloader/tst_qquickloader.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/quick/qquickloader/tst_qquickloader.cpp	2021-11-16 15:55:38.999626525 +0300
@@ -132,6 +132,7 @@
     void statusChangeOnlyEmittedOnce();
 
     void setSourceAndCheckStatus();
+    void asyncLoaderRace();
 };
 
 Q_DECLARE_METATYPE(QList<QQmlError>)
@@ -1491,6 +1492,24 @@
     QCOMPARE(loader->status(), QQuickLoader::Null);
 }
 
+void tst_QQuickLoader::asyncLoaderRace()
+{
+    QQmlApplicationEngine engine;
+    auto url = testFileUrl("loader-async-race.qml");
+    engine.load(url);
+    auto root = engine.rootObjects().at(0);
+    QVERIFY(root);
+
+    QQuickLoader *loader = root->findChild<QQuickLoader *>();
+    QCOMPARE(loader->active(), false);
+    QCOMPARE(loader->status(), QQuickLoader::Null);
+    QCOMPARE(loader->item(), nullptr);
+
+    QSignalSpy spy(loader, &QQuickLoader::itemChanged);
+    QVERIFY(!spy.wait(100));
+    QCOMPARE(loader->item(), nullptr);
+}
+
 QTEST_MAIN(tst_QQuickLoader)
 
 #include "tst_qquickloader.moc"
diff -Nuar a/tests/auto/quick/qquickstates/data/revertNullObjectBinding.qml b/tests/auto/quick/qquickstates/data/revertNullObjectBinding.qml
--- a/tests/auto/quick/qquickstates/data/revertNullObjectBinding.qml	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/quick/qquickstates/data/revertNullObjectBinding.qml	2021-11-16 15:55:38.999626525 +0300
@@ -0,0 +1,48 @@
+import QtQuick 2.12
+import Qt.test 1.0
+
+Item {
+    id: root
+    readonly property int someProp: 1234
+
+    property bool state1Active: false
+    property bool state2Active: false
+    StateGroup {
+        states: [
+            State {
+                id: state1
+                name: "state1"
+                when: state1Active
+                changes: [
+                    PropertyChanges {
+                        objectName: "propertyChanges1"
+                        target: ContainingObj.obj
+                        prop: root.someProp
+                    }
+                ]
+            }
+    ]}
+    StateGroup {
+        states: [
+            State {
+                id: state2
+                name: "state2"
+                when: state2Active
+                changes: [
+                    PropertyChanges {
+                        objectName: "propertyChanges2"
+                        target: ContainingObj.obj
+                        prop: 11111
+                    }
+                ]
+            }
+        ]
+    }
+
+    Component.onCompleted: {
+        state1Active = true;
+        state2Active = true;
+
+        ContainingObj.reset()
+    }
+}
diff -Nuar a/tests/auto/quick/qquickstates/tst_qquickstates.cpp b/tests/auto/quick/qquickstates/tst_qquickstates.cpp
--- a/tests/auto/quick/qquickstates/tst_qquickstates.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/quick/qquickstates/tst_qquickstates.cpp	2021-11-16 15:55:39.000626525 +0300
@@ -79,6 +79,55 @@
 QML_DECLARE_TYPE(MyRect)
 QML_DECLARE_TYPEINFO(MyRect, QML_HAS_ATTACHED_PROPERTIES)
 
+class RemovableObj : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(int prop READ prop WRITE setProp NOTIFY propChanged)
+
+public:
+    RemovableObj(QObject *parent) : QObject(parent), m_prop(4321) { }
+    int prop() const { return m_prop; }
+
+public slots:
+    void setProp(int prop)
+    {
+        if (m_prop == prop)
+            return;
+
+        m_prop = prop;
+        emit propChanged(m_prop);
+    }
+
+signals:
+    void propChanged(int prop);
+
+private:
+    int m_prop;
+};
+
+class ContainingObj : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(RemovableObj *obj READ obj NOTIFY objChanged)
+    RemovableObj *m_obj;
+
+public:
+    ContainingObj() : m_obj(new RemovableObj(this)) { }
+    RemovableObj *obj() const { return m_obj; }
+
+    Q_INVOKABLE void reset()
+    {
+        if (m_obj) {
+            m_obj->deleteLater();
+        }
+
+        m_obj = new RemovableObj(this);
+        emit objChanged();
+    }
+signals:
+    void objChanged();
+};
+
 class tst_qquickstates : public QQmlDataTest
 {
     Q_OBJECT
@@ -140,12 +189,20 @@
     void duplicateStateName();
     void trivialWhen();
     void parentChangeCorrectReversal();
+    void revertNullObjectBinding();
 };
 
 void tst_qquickstates::initTestCase()
 {
     QQmlDataTest::initTestCase();
     qmlRegisterType<MyRect>("Qt.test", 1, 0, "MyRectangle");
+    qmlRegisterSingletonType<ContainingObj>(
+            "Qt.test", 1, 0, "ContainingObj", [](QQmlEngine *engine, QJSEngine *) {
+                static ContainingObj instance;
+                engine->setObjectOwnership(&instance, QQmlEngine::CppOwnership);
+                return &instance;
+            });
+    qmlRegisterUncreatableType<RemovableObj>("Qt.test", 1, 0, "RemovableObj", "Uncreatable");
 }
 
 QByteArray tst_qquickstates::fullDataPath(const QString &path) const
@@ -1692,6 +1749,17 @@
     QCOMPARE(oldX, stayingRectX.read().toDouble());
 }
 
+void tst_qquickstates::revertNullObjectBinding()
+{
+    QQmlEngine engine;
+
+    QQmlComponent c(&engine, testFileUrl("revertNullObjectBinding.qml"));
+    QScopedPointer<QObject> root { c.create() };
+    QVERIFY(root);
+    QTest::qWait(10);
+    QQmlProperty state2Active(root.get(), "state2Active");
+    state2Active.write(false);
+}
 
 QTEST_MAIN(tst_qquickstates)
 
diff -Nuar a/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp b/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp
--- a/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp	2021-11-16 15:55:39.001626525 +0300
@@ -176,6 +176,7 @@
     void checkSyncView_connect_late_data();
     void checkSyncView_connect_late();
     void checkSyncView_pageFlicking();
+    void checkSyncView_emptyModel();
     void delegateWithRequiredProperties();
     void checkThatFetchMoreIsCalledWhenScrolledToTheEndOfTable();
     void replaceModel();
@@ -2731,6 +2732,48 @@
     QVERIFY(tableViewPrivate->scheduledRebuildOptions & QQuickTableViewPrivate::RebuildOption::CalculateNewTopLeftRow);
 }
 
+void tst_QQuickTableView::checkSyncView_emptyModel()
+{
+    // When a tableview has a syncview with an empty model then it should still be
+    // showing the tableview without depending on the syncview. This is particularly
+    // important for headerviews for example
+    LOAD_TABLEVIEW("syncviewsimple.qml");
+    GET_QML_TABLEVIEW(tableViewH);
+    GET_QML_TABLEVIEW(tableViewV);
+    GET_QML_TABLEVIEW(tableViewHV);
+    QQuickTableView *views[] = {tableViewH, tableViewV, tableViewHV};
+
+    auto model = TestModelAsVariant(100, 100);
+
+    for (auto view : views)
+        view->setModel(model);
+
+    WAIT_UNTIL_POLISHED_ARG(tableViewHV);
+
+    // Check that geometry properties are mirrored
+    QCOMPARE(tableViewH->columnSpacing(), tableView->columnSpacing());
+    QCOMPARE(tableViewH->rowSpacing(), 0);
+    QCOMPARE(tableViewH->contentWidth(), tableView->contentWidth());
+    QVERIFY(tableViewH->contentHeight() > 0);
+    QCOMPARE(tableViewV->columnSpacing(), 0);
+    QCOMPARE(tableViewV->rowSpacing(), tableView->rowSpacing());
+    QCOMPARE(tableViewV->contentHeight(), tableView->contentHeight());
+    QVERIFY(tableViewV->contentWidth() > 0);
+
+    QCOMPARE(tableViewH->contentX(), tableView->contentX());
+    QCOMPARE(tableViewH->contentY(), 0);
+    QCOMPARE(tableViewV->contentX(), 0);
+    QCOMPARE(tableViewV->contentY(), tableView->contentY());
+    QCOMPARE(tableViewHV->contentX(), tableView->contentX());
+    QCOMPARE(tableViewHV->contentY(), tableView->contentY());
+
+    QCOMPARE(tableViewHPrivate->loadedTableOuterRect.left(), tableViewPrivate->loadedTableOuterRect.left());
+    QCOMPARE(tableViewHPrivate->loadedTableOuterRect.top(), 0);
+
+    QCOMPARE(tableViewVPrivate->loadedTableOuterRect.top(), tableViewPrivate->loadedTableOuterRect.top());
+    QCOMPARE(tableViewVPrivate->loadedTableOuterRect.left(), 0);
+}
+
 void tst_QQuickTableView::checkThatFetchMoreIsCalledWhenScrolledToTheEndOfTable()
 {
     LOAD_TABLEVIEW("plaintableview.qml");
diff -Nuar a/tests/auto/quick/qquicktext/tst_qquicktext.cpp b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
--- a/tests/auto/quick/qquicktext/tst_qquicktext.cpp	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/quick/qquicktext/tst_qquicktext.cpp	2021-11-16 15:55:39.002626525 +0300
@@ -2243,6 +2243,43 @@
     QCOMPARE(myText->lineCount(), 2);
     QCOMPARE(myText->truncated(), true);
     QCOMPARE(myText->maximumLineCount(), 2);
+
+    // QTBUG-84458
+    myText->resetMaximumLineCount();
+    myText->setText("qqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 2);
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::HorizontalFit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::VerticalFit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::Fit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    QScopedPointer<QQuickView> layoutWindow(createView(testFile("lineLayoutHAlign.qml")));
+    QQuickText *lineLaidOut = layoutWindow->rootObject()->findChild<QQuickText*>("myText");
+    QVERIFY(lineLaidOut != nullptr);
+
+    lineLaidOut->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(lineLaidOut->lineCount(), 3);
+    lineLaidOut->setFontSizeMode(QQuickText::FixedSize);
+    lineLaidOut->setText("");
+    QCOMPARE(lineLaidOut->lineCount(), 1);
 }
 
 void tst_qquicktext::lineHeight()
diff -Nuar a/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml b/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml
--- a/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml	2021-11-16 15:55:39.002626525 +0300
@@ -0,0 +1,30 @@
+import QtQml 2.12
+import QtQml.Models 2.12
+import QtQuick 2.12
+
+Item {
+    height: 480
+    width: 320
+    Rectangle {
+        id: rootRect
+
+        function addItem(desc) {
+            myModel.append({"desc": desc});
+        }
+
+        Rectangle {
+            ListView {
+                objectName: "listView"
+                delegate: Text {
+                    required property string desc
+                    text: desc
+                }
+                model: ListModel { id: myModel }
+            }
+        }
+
+        Component.onCompleted: {
+            addItem("Test creation of a delegate with a property");
+        }
+    }
+}
diff -Nuar a/tests/auto/quick/qquickview_extra/qquickview_extra.pro b/tests/auto/quick/qquickview_extra/qquickview_extra.pro
--- a/tests/auto/quick/qquickview_extra/qquickview_extra.pro	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/quick/qquickview_extra/qquickview_extra.pro	2021-11-16 15:55:39.002626525 +0300
@@ -0,0 +1,12 @@
+CONFIG += testcase
+TARGET = tst_qquickview_extra
+macx:CONFIG -= app_bundle
+
+SOURCES += tst_qquickview_extra.cpp
+
+include (../../shared/util.pri)
+include (../shared/util.pri)
+
+TESTDATA = data/*
+
+QT += core-private gui-private qml-private quick-private testlib
diff -Nuar a/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp b/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp
--- a/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp	2021-11-16 15:55:39.002626525 +0300
@@ -0,0 +1,77 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtest.h>
+#include <QtTest/QSignalSpy>
+#include <QtQuick/qquickview.h>
+#include <QtQuick/qquickitem.h>
+#include <QtQml/qqmlengine.h>
+#include "../../shared/util.h"
+#include <QtCore/QDebug>
+#include <QtCore/QTimer>
+
+// Extra app-less tests
+class tst_QQuickViewExtra : public QQmlDataTest
+{
+    Q_OBJECT
+public:
+    tst_QQuickViewExtra();
+
+private slots:
+    void qtbug_87228();
+};
+
+tst_QQuickViewExtra::tst_QQuickViewExtra() { }
+
+void tst_QQuickViewExtra::qtbug_87228()
+{
+    QScopedPointer<QSignalSpy> deletionSpy;
+    {
+        int argc = 0;
+        QGuiApplication app(argc, nullptr);
+        QQuickView view;
+
+        view.setSource(testFileUrl("qtbug_87228.qml"));
+        view.show();
+        QTimer::singleShot(500, &app, QCoreApplication::quit);
+        app.exec();
+
+        QObject *listView = view.findChild<QObject *>("listView");
+        QVERIFY(listView);
+        QQuickItem *contentItem = listView->property("contentItem").value<QQuickItem *>();
+        QVERIFY(contentItem);
+        auto children = contentItem->childItems();
+        QVERIFY(children.size() > 0);
+        // for the sake of this test, any child would be suitable, so pick first
+        deletionSpy.reset(new QSignalSpy(children[0], SIGNAL(destroyed(QObject *))));
+    }
+    QCOMPARE(deletionSpy->count(), 1);
+}
+
+QTEST_APPLESS_MAIN(tst_QQuickViewExtra)
+
+#include "tst_qquickview_extra.moc"
diff -Nuar a/tests/auto/quick/quick.pro b/tests/auto/quick/quick.pro
--- a/tests/auto/quick/quick.pro	2020-10-27 11:02:12.000000000 +0300
+++ b/tests/auto/quick/quick.pro	2021-11-16 15:55:39.002626525 +0300
@@ -85,6 +85,7 @@
     qquicktextinput \
     qquickvisualdatamodel \
     qquickview \
+    qquickview_extra \
     qquickcanvasitem \
     qquickdesignersupport \
     qquickscreen \
diff -Nuar a/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml b/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml
--- a/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml	1970-01-01 02:00:00.000000000 +0200
+++ b/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml	2021-11-16 15:55:39.003626525 +0300
@@ -0,0 +1,91 @@
+import QtQuick 2.0
+
+//vary font style, native rendering at non-integer offsets
+
+Item {
+    id: topLevel
+    width: 320
+    height: 580
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 20 * index
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 100.5 + 20 * index
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 200.5 + 20 * index
+            x: 0.5
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 300.5 + 20 * index
+            x: 0.5
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Rectangle {
+            y: 400.5 + 20 * index
+            x: 0.5
+            width: topLevel.width
+            height: topLevel.height
+            clip: true
+            Text {
+                renderType: Text.NativeRendering
+                width: parent.width
+                wrapMode: Text.Wrap
+                font.pointSize: 10
+                style: modelData
+                styleColor: "green"
+                text: "The quick fox jumps in style " + modelData
+            }
+        }
+    }
+}
diff -Nuar a/tools/qmltime/qmltime.pro b/tools/qmltime/qmltime.pro
--- a/tools/qmltime/qmltime.pro	2020-10-27 11:02:12.000000000 +0300
+++ b/tools/qmltime/qmltime.pro	2021-11-16 15:55:39.003626525 +0300
@@ -1,4 +1,3 @@
-TEMPLATE = app
 TARGET = qmltime
 QT += qml quick
 QT += quick-private
@@ -12,3 +11,5 @@
 
 SOURCES += qmltime.cpp
 HEADERS += qmltime.h
+
+load(qt_tool)
